const E=(e,t)=>t.some(n=>e instanceof n);let p,B;function k(){return p||(p=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function M(){return B||(B=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const w=new WeakMap,m=new WeakMap,b=new WeakMap,f=new WeakMap,I=new WeakMap;function S(e){const t=new Promise((n,r)=>{const o=()=>{e.removeEventListener("success",c),e.removeEventListener("error",s)},c=()=>{n(d(e.result)),o()},s=()=>{r(e.error),o()};e.addEventListener("success",c),e.addEventListener("error",s)});return t.then(n=>{n instanceof IDBCursor&&w.set(n,e)}).catch(()=>{}),I.set(t,e),t}function C(e){if(m.has(e))return;const t=new Promise((n,r)=>{const o=()=>{e.removeEventListener("complete",c),e.removeEventListener("error",s),e.removeEventListener("abort",s)},c=()=>{n(),o()},s=()=>{r(e.error||new DOMException("AbortError","AbortError")),o()};e.addEventListener("complete",c),e.addEventListener("error",s),e.addEventListener("abort",s)});m.set(e,t)}let D={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return m.get(e);if(t==="objectStoreNames")return e.objectStoreNames||b.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return d(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function L(e){D=e(D)}function P(e){return e===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...n){const r=e.call(y(this),t,...n);return b.set(r,t.sort?t.sort():[t]),d(r)}:M().includes(e)?function(...t){return e.apply(y(this),t),d(w.get(this))}:function(...t){return d(e.apply(y(this),t))}}function j(e){return typeof e=="function"?P(e):(e instanceof IDBTransaction&&C(e),E(e,k())?new Proxy(e,D):e)}function d(e){if(e instanceof IDBRequest)return S(e);if(f.has(e))return f.get(e);const t=j(e);return t!==e&&(f.set(e,t),I.set(t,e)),t}const y=e=>I.get(e);function v(e,t,{blocked:n,upgrade:r,blocking:o,terminated:c}={}){const s=indexedDB.open(e,t),l=d(s);return r&&s.addEventListener("upgradeneeded",a=>{r(d(s.result),a.oldVersion,a.newVersion,d(s.transaction),a)}),n&&s.addEventListener("blocked",a=>n(a.oldVersion,a.newVersion,a)),l.then(a=>{c&&a.addEventListener("close",()=>c()),o&&a.addEventListener("versionchange",u=>o(u.oldVersion,u.newVersion,u))}).catch(()=>{}),l}const T=["get","getKey","getAll","getAllKeys","count"],x=["put","add","delete","clear"],h=new Map;function g(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(h.get(t))return h.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,o=x.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(o||T.includes(n)))return;const c=async function(s,...l){const a=this.transaction(s,o?"readwrite":"readonly");let u=a.store;return r&&(u=u.index(l.shift())),(await Promise.all([u[n](...l),o&&a.done]))[0]};return h.set(t,c),c}L(e=>({...e,get:(t,n,r)=>g(t,n)||e.get(t,n,r),has:(t,n)=>!!g(t,n)||e.has(t,n)}));let i=null;const A=async e=>{try{i=await v(e.name,e.version,{upgrade(t){e.objectStoresMeta.forEach(n=>{if(!t.objectStoreNames.contains(n.store)){let r=t.createObjectStore(n.store,n.storeConfig);n.storeSchema.forEach(o=>{r.createIndex(o.key,o.value)})}})}})}catch(t){console.error("Failed to open db:",t)}},F=async(e,t)=>{try{return i==null?void 0:i.get(e,t)}catch(n){return console.error("Failed to get:",n),null}},V=async(e,t)=>{try{return i==null?void 0:i.delete(e,t)}catch(n){return console.error("Failed to remove:",n),null}},W=async(e,t)=>{try{return i==null?void 0:i.put(e,t)}catch(n){return console.error("Failed to update:",n),null}},K=async e=>{try{return await i.transaction(e,"readonly").objectStore(e).getAllKeys()}catch(t){return console.error("Failed to get all keys:",t),null}},O={name:"BitBoxTools",version:2,objectStoresMeta:[{store:"starkTransactions",storeConfig:{keyPath:"address",autoIncrement:!1},storeSchema:[{key:"address",value:"address"},{key:"data",value:"data"}]},{store:"zkTransactions",storeConfig:{keyPath:"address",autoIncrement:!1},storeSchema:[{key:"address",value:"address"},{key:"data",value:"data"}]},{store:"zkProtocol",storeConfig:{keyPath:"address",autoIncrement:!1},storeSchema:[{key:"address",value:"address"},{key:"data",value:"data"}]}]};export{K as a,O as d,F as g,A as i,V as r,W as u};
